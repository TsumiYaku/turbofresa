#!/usr/bin/env python3
"""
    T.U.R.B.O.F.R.E.S.A.
    Turboaggeggio Utile alla Rimorzione di Byte Obrobriosi e di abominevoli
    File da dischi rigidi Riciclati ed altri Elettronici Sistemi di
    Accumulazione (semi)permanente di dati.
    Copyright (C) 2018  Hyd3L

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import os
import sys
import datetime
import threading

LOG_PATH = '../log.txt'
ERROR, WARNING, INFO = range(0,3)
op_b, op_f, op_p, op_c = range(0,4)
VERBOSITY = INFO


"""
    @return a formatted string containing current date and time
"""
def now():
    return datetime.datetime.now().strftime('[%Y-%m-%d %H:%M:%S] ')


"""
    Console : class for printing errors, warnings and info messages
              to the stdout and into the log file.

    @member printLevel : verbosity level (ERROR, WARNING or INFO)
    @member logFile    : the log file pointer

    @method info : prints info msg to stdout and to the logFile
    @method warn : prints warning to stdout and to the logFile
    @method err  : prints error to stdout and to the logFile
"""
class Console(object):
    def __init__(self):
        self.printLevel = VERBOSITY
        try:
            self.logFile = open(LOG_PATH, "a")
        except IOError:
            print("error: Permission denied. Log file couldn't be created.")
            sys.exit(1)

    def info(self, str):
        if self.printLevel >= INFO:
            print("info: "+str)
            self.logFile.write(now()+"info: "+str+'\n')

    def warn(self, str):
        if self.printLevel >= WARNING:
            print("warning: "+str)
            self.logFile.write(now()+"warning: "+str+'\n')

    def error(self, str):
        if self.printLevel >= ERROR:
            print("error: "+str)
            self.logFile.write(now()+"error: "+str+'\n')

    def exit(self):
        self.logFile.write(now()+"Quit!"+'\n')
        self.logFile.close()

# Initialize log
log = Console()


"""
    Task : class for the runnable thread

    @member disk  : the disk dev path (eg. /dev/sdb )
    @member tasks : things to be done with the disk

    @method run : creates a new thread and runs it
"""
class Task(object):
    def __init__(self):
        self.disk = str()
        self.tasks = list()

    def device(self):
        return self.disk

    def operations(self):
        return self.tasks

    def run(self):
        pass

"""
	Parse command line args.
    tasks : list of tuples containing ("/dev/sdX", [op_b, op_f, op_p, op_c])
	@return list of Task() objects, ready to be run
"""
def parseArgs():
    argc = len(sys.argv)
    args = sys.argv
    tasks = list()

    try:
        if argc < 2:
            raise SyntaxError
        elif args[1] == '-h' or args[1] == '--help':
            # Print the help message and quit
            pass
        else:
            for i in range(1, argc):
                ops = [False, False, False, False]
                if args[i].startswith('-'):
                    for o in range(1,len(args[i])):
                        if 'b' in args[i]:
                            ops[op_b] = True
                        if 'f' in args[i]:
                            ops[op_f] = True
                        if 'p' in args[i]:
                            ops[op_p] = True
                        if 'c' in args[i]:
                            ops[op_c] = True
                    i += 1
                    while args[i].startswith('/'):
                        tasks.append((args[i], ops))
                        if i + 1 == argc: break
                        i += 1
                    if not args[i].startswith('/'):
                        if not args[i].startswith('-'):
                            raise SyntaxError
    except SyntaxError:
        log.error("Invalid syntax detected.")
        log.quit()
        sys.exit(1)
    return tasks

tasks = parseArgs()
