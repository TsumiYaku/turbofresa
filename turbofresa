#!/usr/bin/python
"""
    T.U.R.B.O.F.R.E.S.A.
    Turboaggeggio Utile alla Rimorzione di Byte Obrobriosi e di Abominevoli
    File da dischi rigidi Riciclati ed altri Elettronici Sistemi di
    Accumulazione (semi)permanente di dati.
    Copyright (C) 2018  Hyd3L

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

import os
import sys
import argparse
import datetime
import threading

LOG_PATH = 'log.txt'
ERROR, WARNING, INFO = range(0,3)
op_b, op_f, op_p, op_c = range(0,4)
VERBOSITY = INFO

"""
    @return a formatted string containing current date and time
"""
def now():
    return datetime.datetime.now().strftime('[%Y-%m-%d %H:%M:%S] ')


"""
    Console : class for printing errors, warnings and info messages
              to the stdout and into the log file.

    @member printLevel : verbosity level (ERROR, WARNING or INFO)
    @member logFile    : the log file pointer

    @method info : prints info msg to stdout and to the logFile
    @method warn : prints warning to stdout and to the logFile
    @method err  : prints error to stdout and to the logFile
"""
class Console(object):
    def __init__(self):
        self.printLevel = VERBOSITY
        self.logFile = open(LOG_PATH, "a")
        if self.logFile is None:
            print("error: Permission denied. Log file couldn't be created.")
            sys.exit(1)

    def info(self, str):
        if self.printLevel >= INFO:
            print("info: "+str)
            self.logFile.write(now()+"info: "+str+'\n')

    def warn(self, str):
        if self.printLevel >= WARNING:
            print("warning: "+str)
            self.logFile.write(now()+"warning: "+str+'\n')

    def error(self, str):
        if self.printLevel >= ERROR:
            print("error: "+str)
            self.logFile.write(now()+"error: "+str+'\n')


"""
    Program : Main class

    @member log   : Console instance
    @member argc  : command line arguments counter
    @member args  : list of command line arguments
    @member disks : list of tuples containing the disks paths and the
                    operations to be accomplished.

    @method cmdString : converts the member args to a string
    @method help      : printsop_b = op_f = op_p = op_c = False an help message and quit
    @method parseArgs : parse arguments and store the result in member disks
"""
class Program(object):
    def __init__(self):
        self.log = Console()
        self.argc = len(sys.argv)
        self.args = argparse.ArgumentParser()
        self.disks = list()

    def cmdString(self):
        cmd = str()
        for p in self.args:
            cmd += (p + " ")
        return cmd

    def help(self):
        helpstr = \
"""T.U.R.B.O.F.R.E.S.A.
Turboaggeggio Utile alla Rimorzione di Byte Obrobriosi e di Abominevoli
File da dischi rigidi Riciclati ed altri Elettronici Sistemi di
Accumulazione (semi)permanente di dati.
Copyright (C) 2018  Hyd3L
This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type 'show c' for details.

usage: <program> -options /dev/sdX /dev/sdY -options /dev/sdZ ...

options:
  -b : search for bad blocks on the disk plate
  -f : fast mode (single pass)
  -p : paranoid mode (multiple passes)
  -c : final check
  --shutdown :
"""
        print(helpstr)
        quit()

    def parseArgs(self):
        self.log.info('user: '+self.cmdString())
        if self.argc < 2:
            self.log.error("Invalid syntax detected.")
            quit()

        if self.args[1] == '-h' or self.args[1] == '--help':
            self.help()

        for i in range(1, self.argc):
            ops = [False, False, False, False]

            if self.args[i].startswith('-'):
                for o in range(1,len(self.args[i])):
                    if 'b' in self.args[i]:
                        ops[op_b] = True
                    if 'f' in self.args[i]:
                        ops[op_f] = True
                    if 'p' in self.args[i]:
                        ops[op_p] = True
                    if 'c' in self.args[i]:
                        ops[op_c] = True
                i += 1
                if not self.args[i].startswith('/'):
                    self.log.error("Invalid syntax detected.")
                    quit()
                while self.args[i].startswith('/') and not i+1 == self.argc:
                    self.disks.append((self.args[i], ops))
                    if not i + 1 == self.argc:
                        i += 1
            else:
                self.log.error("Invalid syntax detected.")
                quit()


    def run(self):
        pass

    def __del__(self):
        if self.log.logFile is not None:
            self.log.logFile.close()
            print("Log file closed.")

main = Program()
main.parseArgs()
